Code von pathfinder.html:


<html>
    <head>
        <meta charset="utf-8">
        <link href="pathfinder.css" rel="stylesheet" type="text/css">
    </head>
    
    <body>
        <canvas id="canvasMenu" width="1200" height="200"> </canvas>
        <canvas width="1200" height="20"> </canvas> <!-- PLACEHOLDER -->
        <canvas id="canvasPlayground" width="1200" height="800"> </canvas>
        <button type="buttontop" id="start" class="buttonsTop" onclick="setStartpointTrue();setStartpoint();">Set Startpoint</button>
        <button type="buttontop" id="end" class="buttonsTop" onclick="setEndpointTrue();setEndpoint();">Set Endpoint</button>
        <button type="buttontop" id="barriers" class="buttonsTop" onclick="barriersCounter();">Edit barriers</button>
        <button type="buttontop" id="rects" class="buttonsTop" onclick="setRects();">Set number of squares</button>
        <button type="buttontop" id="maze" class="buttonsTop" onclick="generateMaze();">Generate a Maze</button>
        <button type="buttonlow" id="clear" class="buttonsLow" onclick="clearField();">Clear the field</button>
        <button type="buttonlow" id="findBFS" class="buttonsLow" onclick="startSearchBFS();">Find Path with BFS!</button>
        <button type="buttonlow" id="findAStar" class="buttonsLow" onclick="startSearchAStar();">Find Path with AStar!</button>
        
        <script src="quicksort.js" type="text/javascript"> </script>
        <script src="maze.js" type="text/javascript"> </script>
        <script src="functions.js" type="text/javascript"> </script>
        <script src="BFS_Algorithm.js" type="text/javascript"> </script>
        <script src="aStar_Algorithm.js" type="text/javascript"> </script>
        <script src="pathfinder.js" type="text/javascript"> </script>

    </body>
    
    </html>


Code von pathfinder.css:


#canvasMenu {
  border: 3px solid black;
  background-color: rgb(213, 241, 250);
}

#canvasPlayground {
  border: 3px solid black;
}

#start {
  left: 100px;
}

#end {
  left: 300px;
}

#barriers {
  left: 500px;
}

#rects {
  left: 700px;
}

#maze {
  left: 900px;
}

#findBFS {
  left: 100px;
}

#findAStar {
  left: 300px;
}

#clear {
  left: 900px;
}

.buttonsTop {
  position: absolute;
  top: 40px;
  width: 120px;
  height: 50px;
  background-color: rgb(213, 241, 250);
  border: 1px solid black;
}

.buttonsLow {
  position: absolute;
  top: 130px;
  width: 120px;
  height: 50px;
  background-color: rgb(213, 241, 250);
  border: 1px solid black;
}

.buttonActiv {
  background: #e5e5e5;
  -webkit-box-shadow: inset 0px 0px 7px #686868;
  -moz-box-shadow: inset 0px 0px 7px #686868;
  box-shadow: inset 0px 0px 7px #686868;
  outline: none;
}


Code von pathfinder.js:

let canvas = document.getElementById("canvasPlayground");
let ctx = canvas.getContext("2d");
let cols = 15;
let rows = 10;
let field = new Array();
let screen_height = canvas.height;
let screen_width = canvas.width;
let cellX = null;
let cellY = null;
let loopEnd_start = false;
let loopEnd_end = false;
let loopEnd_barriers = false;
let barrier_counter = 0;
let barrier_loop = null;

setup();

function setup() {
    for (i = 0; i < rows; i++) {
        field.push(new Array());
        for (j = 0; j < cols; j++) {
            field[i].push("0");
        }  
    }
    draw();
}

function grid() {
    // VERTICAL
    for(i = screen_width / cols; i < screen_width; i+= (screen_width / cols)) {
        ctx.beginPath();
        ctx.lineWidth = 1;
        ctx.strokeStyle = "black";
        ctx.moveTo(i, 0);
        ctx.lineTo(i, screen_height);
        ctx.stroke();
    }
    
    // HORIZONTAL
    for(i = screen_height / rows; i < screen_height; i+= (screen_height / rows)) {
        ctx.beginPath();
        ctx.strokeStyle = 'black';
        ctx.moveTo(0, i);
        ctx.lineTo(screen_width, i);
        ctx.stroke();
    }
}

function clearField() {
    for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++) {
            field[i][j] = "0"
        }
    }
    draw();
}

function draw() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    grid();

    for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++) {
            switch (field[i][j]) {
                case "s":
                    ctx.beginPath();
                    ctx.strokeStyle = 'blue';
                    ctx.lineWidth = 3;
                    ctx.moveTo((j + 1) * (screen_width / cols) - (screen_width / cols), (i + 1) * (screen_height / rows) - (screen_height / rows));
                    ctx.lineTo((j + 1) * (screen_width / cols), (i + 1) * (screen_height / rows));
                    ctx.moveTo((j + 1) * (screen_width / cols) - (screen_width / cols), (i + 1) * (screen_height / rows));
                    ctx.lineTo((j + 1) * (screen_width / cols), (i + 1) * (screen_height / rows) - (screen_height / rows));
                    ctx.stroke();
                    break;
                case "e":
                    ctx.beginPath();
                    ctx.strokeStyle = 'red';
                    ctx.lineWidth = 3;
                    ctx.moveTo((j + 1) * (screen_width / cols) - (screen_width / cols), (i + 1) * (screen_height / rows) - (screen_height / rows));
                    ctx.lineTo((j + 1) * (screen_width / cols), (i + 1) * (screen_height / rows));
                    ctx.moveTo((j + 1) * (screen_width / cols) - (screen_width / cols), (i + 1) * (screen_height / rows));
                    ctx.lineTo((j + 1) * (screen_width / cols), (i + 1) * (screen_height / rows) - (screen_height / rows));
                    ctx.stroke();
                    break;
                case "b":
                    fillRect(i, j, "black");
                    break;
                case "p":
                    fillRect(i, j, "green");
                    break;
                case "x":
                    fillRect(i, j, "blue");
                    break;
            }
        }  
    }
    //switch 
}
function startSearchBFS() {
    path = findPathWithBFS(field);
    for (i = 0; i < path.length; i++) { 
        field[path[i].x][path[i].y] = "p";
    }
    console.log("path: ", path)
    draw();
}
function startSearchAStar() {
    path = findPathWithAStar(field);
    for (i = 0; i < path.length; i++) { 
       field[path[i].y][path[i].x] = "p";
    }
    console.log("path: ", path)
    draw();
}

function fillRect(y, x, color) {
    ctx.beginPath;
    ctx.fillStyle = color;
    ctx.fillRect(x * (screen_width / cols) + 1, y * (screen_height / rows) + 1, screen_width / cols - 2, screen_height / rows - 2);
}

function getCell(x, y) {
    for(i = 0; i < screen_height; i+= (screen_height / rows)) {
        if (y > i + 157 && y < i + (screen_height / rows) + 157) {
            cellY = i / (screen_height / rows);
        }
    }
    for (j = 0; j < screen_width; j+= (screen_width / cols)) {
        if (x > j + 10 && x < j + (screen_width / cols) + 10) {
            cellX = j / (screen_width / cols);
        }
    }
}

function generateMaze() {

}

//STARTPOINT
function setStartpoint() {
    if (!loopEnd_start) {
        document.getElementById('start').classList.add("buttonActiv");
        canvas.addEventListener("click", onClickStartpoint);
        setTimeout(setStartpoint);
    }
}
function onClickStartpoint(e) {
    for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++) {
            if (field[i][j] == "s") {
                field[i][j] = "0";
            }
        }  
    }
    getCell(e.clientX, e.clientY);
    if (cellX != null && cellY != null) { 
        field[cellY][cellX] = "s";
        draw();
    }

    loopEnd_start = true;
    canvas.removeEventListener("click", onClickStartpoint);
    document.getElementById('start').classList.remove("buttonActiv");
}
function setStartpointTrue() {
    loopEnd_start = false;
}


function setRects() {
    field = new Array();
    cols = prompt("Number of columns: ", );
    rows = prompt("Number of rows: ", );
    setup();
}
//ENDPOINT
function setEndpoint() {
    if (!loopEnd_end) {
        document.getElementById('end').classList.add("buttonActiv");
        canvas.addEventListener("click", onClickEndpoint);
        setTimeout(setEndpoint);
    }
}
function onClickEndpoint(e) {
    for (i = 0; i < rows; i++) {
        for (j = 0; j < cols; j++) {
            if (field[i][j] == "e") {
                field[i][j] = "0";
            }
        }  
    }
    getCell(e.clientX, e.clientY);
    if (cellX != null && cellY != null) { 
        field[cellY][cellX] = "e";
        draw();
    }

    loopEnd_end = true;
    canvas.removeEventListener("click", onClickEndpoint);
    document.getElementById('end').classList.remove("buttonActiv");
}
function setEndpointTrue() {
    loopEnd_end = false;
}

//BARRIERS
function barriers() {
    if (!loopEnd_barriers) {
        document.getElementById('barriers').classList.add("buttonActiv");
        canvas.addEventListener("mousedown", onClickBarriers);
        barrier_loop = setTimeout(barriers);
    }
}
function onClickBarriers(e) {
    getCell(e.clientX, e.clientY);
    if (cellX != null && cellY != null) { 
        if (field[cellY][cellX] == "0") {
            field[cellY][cellX] = "b";
        }
        else {
            field[cellY][cellX] = "0";
        }
        draw();
    }
}
function barriersCounter() {
    barrier_counter++;
    if (barrier_counter % 2 == 0) {
        barriersEnd();
        clearTimeout(barrier_loop);
    } 
    else {
        barriers();
    }
}
function barriersEnd() {
    canvas.removeEventListener("mousedown", onClickBarriers);
    document.getElementById('barriers').classList.remove("buttonActiv");
}

function generateMaze() {
    field = mazeStart(field);
    draw();
}



code von functions.js:


function getNeighbors(point, field) {
    const neighbors = [];
    let neighbor_north = new Point(point.x, point.y - 1);
    if (neighborValid(neighbor_north, field)) {
        neighbors.push(neighbor_north);
    }
    let neighbor_east = new Point(point.x + 1, point.y);
    if (neighborValid(neighbor_east, field)) {
        neighbors.push(neighbor_east);
    }
    let neighbor_south = new Point(point.x, point.y + 1);
    if (neighborValid(neighbor_south, field)) {
        neighbors.push(neighbor_south);
    }
    let neighbor_west = new Point(point.x - 1, point.y);
    if (neighborValid(neighbor_west, field)) {
        neighbors.push(neighbor_west);
    }
    return neighbors;
}
function neighborValid(point, field) {
    if (point.x >= 0 && point.x < field.length &&
        point.y >= 0 && point.y < field[0].length &&
        (field[point.x][point.y] == "0" || field[point.x][point.y] == "e")) {

        return true;
    }
    else {
        return false;
    }
}



Code von aStar_Algorithm.js:

class AStarCheckpoint {
    constructor(x, y, h, path) {
        this.x = x;
        this.y = y;
        this.h = h;
        this.path = path;
    } 
}
class AStarPoint {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

function AStarGetNeighbors(point, field) {
    const neighbors = [];

    let neighbor_north = new AStarPoint(point.x, point.y - 1);
    if (AStarNeighborValid(neighbor_north, field)) {
        neighbors.push(neighbor_north);
    }

    let neighbor_east = new AStarPoint(point.x + 1, point.y);
    if (AStarNeighborValid(neighbor_east, field)) {
        neighbors.push(neighbor_east);
    }

    let neighbor_south = new AStarPoint(point.x, point.y + 1);
    if (AStarNeighborValid(neighbor_south, field)) {
        neighbors.push(neighbor_south);
    }

    let neighbor_west = new AStarPoint(point.x - 1, point.y);
    if (AStarNeighborValid(neighbor_west, field)) {
        neighbors.push(neighbor_west);
    }
    return neighbors;
}

function AStarNeighborValid(point, field) {
    if (point.x >= 0 && point.x < field.length &&
        point.y >= 0 && point.y < field[0].length &&
        (field[point.x][point.y] == "0" || field[point.x][point.y] == "e")) {

        return true;
    }
    else {
        return false;
    }
}

function findEnd(field) {
    for (i = 0; i < field.length; i++) {
        for (j = 0; j < field[0].length; j++) {
            if (field[i][j] == "e") {
                return new AStarPoint(j, i);
            }
        }
    }
    alert("No end found!")
}

function findStartAndEnd(field) {
    let end = findEnd(field);
    let return_array = new Array(end)
    for (i = 0; i < field.length; i++) {
        for (j = 0; j < field[0].length; j++) {
            if (field[i][j] == "s") {
                let start = new AStarPoint(j, i);
                return_array.push(start);
                return return_array;
            }
        }
    }
    alert("No start found!");
}

function findPathWithAStar(field) {
    return aStarfindPathFromStart(field, findStartAndEnd(field));
}

function manhattenDistance(point_1, point_2) {
    let dist = Math.abs(point_2.x - point_1.x) + Math.abs(point_2.y - point_1.y);
    console.log("Manhatten dist:", point_1, point_2, dist);
    return dist;
}

function newCheckpoint(point, path, end) {
    let heuristic = manhattenDistance(point, end)// + path.length - 1;
    return new AStarCheckpoint(point.x, point.y, heuristic, path);
}

function queueSort(queue) {
    return quickSort(queue, 0, queue.length - 1);
}

function aStarfindPathFromStart(field, points) {
    let end = points[0];
    let start = points[1];
    let queue = [new AStarCheckpoint(start.x, start.y, Number.POSITIVE_INFINITY, [start])];

    while (queue.length > 0) {
        //console.log("BEFORE SORT:", JSON.parse(JSON.stringify(field)));
        queue = queueSort(queue);
        //console.log("AFTER SORT:", JSON.parse(JSON.stringify(queue)));
        let curr_point = queue.shift();
        if (field[curr_point.x][curr_point.y] == "e") {
            return curr_point.path;
        }
        let neighbors = AStarGetNeighbors(curr_point, field);
        if (field[curr_point.x][curr_point.y] != "x") {
            for (let i = 0; i < neighbors.length; i++) {
                let new_path = curr_point.path.slice();
                new_path.push(neighbors[i]);
            
                let new_checkpoint = newCheckpoint(neighbors[i], new_path, end);
                queue.push(new_checkpoint);
            }
        }

        field[curr_point.y][curr_point.x] = "x";
    }
    alert("No path found!");
}


Code von BFS_Algorithm.js:


function BFSfindPathFromStart(field, start) {
    const queue = [new Checkpoint(start, [start])];
    while (queue.length > 0) {
        console.log("AFTER SORT:", JSON.parse(JSON.stringify(queue)));
        let checkpoint = queue.shift();
        if (field[checkpoint.point.x][checkpoint.point.y] == "e")  {
            return checkpoint.path;
        }
        let neighbors = getNeighbors(checkpoint.point, field);
        if (field[checkpoint.point.x][checkpoint.point.y] != "x")  {
            for (i = 0; i < neighbors.length; i++){
                let new_path = checkpoint.path.slice();
                new_path.push(neighbors[i]);
                let new_checkpoint = new Checkpoint(neighbors[i], new_path);
                queue.push(new_checkpoint);
            }
        }
        field[checkpoint.point.x][checkpoint.point.y] = "x";
    }
    alert("No path found!");
}

function findPathWithBFS(field) {
    return BFSfindPathFromStart(field, findStart(field));
}

function findStart(field) {
    for (i = 0; i < field.length; i++) {
        for (j = 0; j < field[0].length; j++) {
            if (field[i][j] == "s") {
                return new Point(j, i);
            }
        }
    }
    alert("No start found!");
}

function getNeighbors(point, field) {
    const neighbors = [];
    let neighbor_north = new Point(point.x, point.y - 1);
    if (neighborValid(neighbor_north, field)) {
        neighbors.push(neighbor_north);
    }
    let neighbor_east = new Point(point.x + 1, point.y);
    if (neighborValid(neighbor_east, field)) {
        neighbors.push(neighbor_east);
    }
    let neighbor_south = new Point(point.x, point.y + 1);
    if (neighborValid(neighbor_south, field)) {
        neighbors.push(neighbor_south);
    }
    let neighbor_west = new Point(point.x - 1, point.y);
    if (neighborValid(neighbor_west, field)) {
        neighbors.push(neighbor_west);
    }
    return neighbors;
}

function neighborValid(point, field) {
    if (point.x >= 0 && point.x < field.length &&
        point.y >= 0 && point.y < field[0].length &&
        (field[point.x][point.y] == "0" || field[point.x][point.y] == "e")) {

        return true;
    }
    else {
        return false;
    }
}

class Point {
    constructor(x, y) {
        this.x = x;
        this.y = y;
    }
}

class Checkpoint {
    constructor(point, path) {
        this.point = point;
        this.path = path;
    } 
}


Code von maze.js:

function mazeStart(field) {
    /*let field = [];
    let y = canvas.height / final_resolution;
    if (y % 2 == 1) {
        y++;
    }
    let x = canvas.width / final_resolution;
    if (x % 2 == 1) {
        x++
    }*/
    let horizontal = isHorizontal(field.length, field[0].length);

    boarder(field)
    recursiveDivision(field, horizontal, 1, field[0].length - 2, 1, field.length - 2);
    return(field);
}

function recursiveDivision(field, horizontal, min_x, max_x, min_y, max_y) {
    if (horizontal) {
        if (max_x - min_x < 2) {
            return;
        }
        let random_y = RandomNumberInRange(min_y, max_y - 1)
        if (random_y % 2 == 1) {
            random_y++;
        }
        horizontalWall(min_x, max_x, random_y, field);
        let dir_1 = isHorizontal(max_x - min_x, (random_y - 1) - min_y);
        let dir_2 = isHorizontal(max_x - min_x, max_y - (random_y + 1));
        recursiveDivision(field, dir_1, min_x, max_x, min_y, random_y - 1);
        recursiveDivision(field, dir_2, min_x, max_x, random_y + 1, max_y);
        //recursiveDivision(field, !horizontal, min_x, max_x, min_y, random_y - 1);
        //recursiveDivision(field, !horizontal, min_x, max_x, random_y + 1, max_y);
    }
    else {
        if (max_y - min_y < 2) {
            return;
        }
        let random_x = RandomNumberInRange(min_x, max_x - 1)
        if (random_x % 2 == 1) {
            random_x++;
        }
        verticalWall(min_y, max_y, random_x, field);
        let dir_3 = isHorizontal((random_x - 1) - min_x, max_y - min_y);
        let dir_4 = isHorizontal(max_x - (random_x + 1), max_y - min_y);
        recursiveDivision(field, dir_3, min_x, random_x - 1, min_y, max_y);
        recursiveDivision(field, dir_4, random_x + 1, max_x, min_y, max_y);
        //recursiveDivision(field, !horizontal, min_x, random_x - 1, min_y, max_y);
        //recursiveDivision(field, !horizontal, random_x + 1, max_x, min_y, max_y);

    }
}

function horizontalWall(min_x, max_x, y, field) {
    let door = RandomNumberInRange(min_x, max_x - 1);
    if (door % 2 == 0) {
        door++;
    }
    for (let x = min_x; x <= max_x; x++) {
        if (x != door) {
            field[y][x] = "b";
        }
        else {
            field[y][x] = "0";
        }
    }
}

function verticalWall(min_y, max_y, x, field) {
    let door = RandomNumberInRange(min_y, max_y - 1);
    if (door % 2 == 0) {
        door++;
    }
    for (let y = min_y; y <= max_y; y++) {
        if (y != door) {
            field[y][x] = "b";
        }
        else {
            field[y][x] = "0";
        }
    }
}

function isHorizontal(width, height) {
    if(width < height) {
        return true;
    }
    else {
        return false;
    }
}

function boarder(field) {
    for (i = 0; i < field.length; i++) {
        if (i == 0 || i == field.length - 1) {
            for (j = 0; j < field[0].length; j++) {
                field[i][j] = "b";
            }
        }
        else {
            field[i][field[0].length - 1] = "b";
            field[i][0] = "b";
        }
    }
}

function RandomNumberInRange(min, max) {
    min = Math.ceil(min);
    max = Math.floor(max);
    let rNumber = Math.floor(Math.random() * (max - min)) + min;
    return rNumber;
}


Code von quicksort.js:


function quicksortChange(array, left, right) {
    let pivot = array[Math.floor((right + left) / 2)].h;

    while (left <= right) {
        while (array[left].h < pivot) {
            left++;
        }
        while (array[right].h > pivot) {
            right--;
        }
        if (left <= right) {
            let tmp = array[left];
            array[left] = array[right];
            array[right] = tmp;
            /*
            let a = array[left].h;
            let b = array[right].h;
            array[left].h = b;
            array[right].h = a;
            */
            left++;
            right--;
        }
    }
    return left;
}

function quickSort(array, left, right) {
    if (array.length > 1) {
        let operator = quicksortChange(array, left, right);
        if (left < operator - 1) {
            quickSort(array, left, operator - 1);
        }
        if (right > operator) {
            quickSort(array, operator, right);
        }
    }
    return array;
}